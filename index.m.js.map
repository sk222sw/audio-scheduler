{"version":3,"file":"index.m.js","sources":["src/util.ts","src/index.ts"],"sourcesContent":["export const last = arr => arr[arr.length - 1];\nexport const withDefault = (fn, def) => fn || def;\nexport const lastWithDefault = (arr, def) => withDefault(last(arr), def);\nexport const first = arr => arr[0];\nexport const firstWithDefault = (arr, def) => withDefault(first(arr), def);\nexport const repeat = (fn: () => void, times: number) => {\n  for (var i = 0; i < times; i++) {\n    fn();\n  }\n};\n","import { first, last } from \"./util\";\n\nexport interface AudioSchedulerOptions {\n  tempo: number;\n  intervalLengths: number[];\n  context?: AudioContext;\n  infinite: boolean;\n  schedulAheadTime?: number;\n  intervalTime?: number;\n}\n\nenum ScheduleMode {\n  Infinite,\n  Finite\n}\n\nexport class AudioScheduler {\n  private scheduleAheadTime: number;\n  private tempo: number;\n  private msTempo: number;\n  private context: AudioContext;\n  private initialIntervals: number[] = [];\n  private setIntervalReference: number;\n  private mode: ScheduleMode;\n  private lastIntervalStartedAt: number;\n  private intervalList: number[] = [];\n  private intervalTime: number;\n\n  constructor(options: AudioSchedulerOptions) {\n    this.mode = options.infinite ? ScheduleMode.Infinite : ScheduleMode.Finite;\n\n    this.initialIntervals = options.intervalLengths;\n    this.scheduleAheadTime = options.schedulAheadTime || 0.1;\n    this.intervalTime = options.intervalTime || 50;\n\n    this.tempo = options.tempo;\n    this.context = options.context || new AudioContext();\n  }\n\n  _init() {\n    this.msTempo = 60000 / this.tempo;\n    this.intervalList = this.initialIntervals;\n  }\n\n  _intervalLengthInMs() {\n    return this.msTempo / 1000;\n  }\n\n  setTempo(newTempo) {\n    this.tempo = newTempo;\n    this.msTempo = 60000 / this.tempo;\n  }\n\n  _scheduler(currentTime, cb) {\n    if (!last(this.intervalList)) {\n      if (this.mode === ScheduleMode.Finite) {\n        this.stopInterval(this.setIntervalReference);\n      } else {\n        this.intervalList = this.initialIntervals;\n      }\n      return;\n    }\n\n    const next = this._calculateNext(first(this.intervalList));\n    const shouldBeScheduled = currentTime + this.scheduleAheadTime;\n\n    if (next < shouldBeScheduled) {\n      this._runCallback(next, cb);\n    }\n  }\n\n  _calculateNext(intervalLength) {\n    return (\n      (this.lastIntervalStartedAt || 0) +\n      intervalLength * this._intervalLengthInMs()\n    );\n  }\n\n  _runCallback(time, cb) {\n    this.intervalList = this.intervalList.slice(1, this.intervalList.length);\n    this.lastIntervalStartedAt = time;\n    cb(time);\n  }\n\n  startInterval(cb: Function) {\n    this._init();\n\n    this._runCallback(this.context.currentTime, cb);\n\n    const interval = setInterval(\n      _ => this._scheduler(this.context.currentTime, cb),\n      this.intervalTime\n    );\n\n    this.setIntervalReference = interval;\n    return interval;\n  }\n\n  stopInterval(interval) {\n    clearInterval(interval);\n  }\n\n  updateIntervals(intervalList: number[]) {\n    this.intervalList = intervalList;\n    this.initialIntervals = intervalList;\n  }\n  push(newInterval: number) {\n    this.intervalList = [...this.intervalList, newInterval];\n    this.initialIntervals = [...this.initialIntervals, newInterval];\n  }\n  shift() {\n    const [_, ...intervals] = this.intervalList;\n    const [__, ...initialIntervals] = this.initialIntervals;\n    this.intervalList = intervals;\n    this.initialIntervals = initialIntervals;\n  }\n  pop() {\n    const intervalList = [...this.intervalList];\n    intervalList.pop();\n    this.intervalList = intervalList;\n\n    const initialIntervals = [...this.initialIntervals];\n    initialIntervals.pop();\n    this.initialIntervals = initialIntervals;\n  }\n}\n"],"names":["ScheduleMode","options","this","mode","infinite","Infinite","Finite","initialIntervals","intervalLengths","scheduleAheadTime","schedulAheadTime","intervalTime","tempo","context","AudioContext","AudioScheduler","msTempo","intervalList","newTempo","currentTime","cb","arr","length","next","_calculateNext","first","_runCallback","stopInterval","setIntervalReference","intervalLength","lastIntervalStartedAt","_intervalLengthInMs","time","slice","_init","interval","setInterval","_","_this","_scheduler","clearInterval","newInterval","_a","intervals","_b","pop"],"mappings":"AAAO,ICWFA,YAAAA,GACHA,2BACAA,wBAFGA,IAAAA,OAKL,iBAYE,WAAYC,GAPJC,yBAIAA,qBAINA,KAAKC,KAAOF,EAAQG,SAAWJ,EAAaK,SAAWL,EAAaM,OAEpEJ,KAAKK,iBAAmBN,EAAQO,gBAChCN,KAAKO,kBAAoBR,EAAQS,kBAAoB,GACrDR,KAAKS,aAAeV,EAAQU,cAAgB,GAE5CT,KAAKU,MAAQX,EAAQW,MACrBV,KAAKW,QAAUZ,EAAQY,SAAW,IAAIC,aAyF1C,OAtFEC,kBAAA,WACEb,KAAKc,QAAU,IAAQd,KAAKU,MAC5BV,KAAKe,aAAef,KAAKK,kBAG3BQ,gCAAA,WACE,OAAOb,KAAKc,QAAU,KAGxBD,qBAAA,SAASG,GACPhB,KAAKU,MAAQM,EACbhB,KAAKc,QAAU,IAAQd,KAAKU,OAG9BG,uBAAA,SAAWI,EAAaC,GACtB,IDtDgBC,ECsDNnB,KAAKe,cDtDYI,EAAIC,OAAS,GCsDxC,CDtDgB,IAAAD,EC+DVE,EAAOrB,KAAKsB,eD5DD,SAAAH,GAAO,OAAAA,EAAI,GC4DKI,CAAMvB,KAAKe,eAGxCM,EAFsBJ,EAAcjB,KAAKO,mBAG3CP,KAAKwB,aAAaH,EAAMH,QAZpBlB,KAAKC,OAASH,EAAaM,OAC7BJ,KAAKyB,aAAazB,KAAK0B,sBAEvB1B,KAAKe,aAAef,KAAKK,kBAa/BQ,2BAAA,SAAec,GACb,OACG3B,KAAK4B,uBAAyB,GAC/BD,EAAiB3B,KAAK6B,uBAI1BhB,yBAAA,SAAaiB,EAAMZ,GACjBlB,KAAKe,aAAef,KAAKe,aAAagB,MAAM,EAAG/B,KAAKe,aAAaK,QACjEpB,KAAK4B,sBAAwBE,EAC7BZ,EAAGY,IAGLjB,0BAAA,SAAcK,GAAd,WACElB,KAAKgC,QAELhC,KAAKwB,aAAaxB,KAAKW,QAAQM,YAAaC,GAE5C,IAAMe,EAAWC,YACf,SAAAC,GAAK,OAAAC,EAAKC,WAAWD,EAAKzB,QAAQM,YAAaC,IAC/ClB,KAAKS,cAIP,OADAT,KAAK0B,qBAAuBO,EACrBA,GAGTpB,yBAAA,SAAaoB,GACXK,cAAcL,IAGhBpB,4BAAA,SAAgBE,GACdf,KAAKe,aAAeA,EACpBf,KAAKK,iBAAmBU,GAE1BF,iBAAA,SAAK0B,GACHvC,KAAKe,aAAmBf,KAAKe,qBAAcwB,IAC3CvC,KAAKK,iBAAuBL,KAAKK,yBAAkBkC,KAErD1B,kBAAA,WACQ,IAAA2B,oBAAIC,aACJC,wBAAKrC,aACXL,KAAKe,aAAe0B,EACpBzC,KAAKK,iBAAmBA,GAE1BQ,gBAAA,WACE,IAAME,EAAmBf,KAAKe,qBAC9BA,EAAa4B,MACb3C,KAAKe,aAAeA,EAEpB,IAAMV,EAAuBL,KAAKK,yBAClCA,EAAiBsC,MACjB3C,KAAKK,iBAAmBA"}